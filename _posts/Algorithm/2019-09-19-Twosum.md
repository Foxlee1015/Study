---
layout: post
title: Leetcode(1~)
categories: Algorithm

---

# 1

* For loop -O(n2) 중첩이 아닌  시간복잡도(n) 으로 사전 이용  ( for i in range(len(nums)) - O(n),  if nums[i] in dic_sum: - O(1) - 사전은 O(1)

* https://leetcode.com/problems/two-sum/submissions/
* https://www.quora.com/What-is-the-time-complexity-of-checking-if-a-key-is-in-a-dictionary-in-Python ( 사전 시간 복잡도)


        class Solution:
            def twoSum(self, nums: List[int], target: int) -> List[int]:
                dic_sum = {}

                if len(nums) <= 1:
                    return False

                for i in range(len(nums)):                        
                    m = target - nums[i]         
                    if nums[i] in dic_sum:
                        return [dic_sum[nums[i]], i]       # return 값은 list에서의 인덱스 값
                    else:
                        dic_sum[m] = i          



# 2

https://leetcode.com/problems/add-two-numbers/


        class ListNode:
            def __init__(self, x):
                self.val = x
                self.next = None

        class Solution:
            def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
                carry = 0                      # 더하고 10 을 넘을 경우 10으로 나눈 후 몫을 받음 ( divmod ) 
                root = n = ListNode(0)         # Answer list
                while l1 or l2 or carry:       # 하나라도 존재 ( 하나 리스트가 다른 하나보다 더 많을 수 있음 )
                    v1 = v2 = 0                # list1, list2 value 받음 
                    if l1:                     
                        v1 = l1.val
                        l1 = l1.next
                    if l2:
                        v2 = l2.val
                        l2 = l2.next        
                                             # v1, v2 로 받고, 그 다음 밸류 받음
                    carry, val = divmod(v1+v2+carry, 10)    # divmod(8,3) =  2, 2 (몫, 나머지)
                    n.next = ListNode(val)                  # next 에 값 넣기 
                    n = n.next                              # 그 다음 값에 접근 
                return root.next
